"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockService = void 0;
const service_1 = require("../../utils/decorators/service");
const mock_repository_1 = require("./mock.repository");
const Handlebars = require("handlebars");
const helpers = require("handlebars-helpers");
const utils_1 = require("../../utils/utils");
const proxy_controller_1 = require("../proxy/proxy.controller");
const mock_failure_1 = require("./data/mock-failure");
const flag_service_1 = require("../flag/flag.service");
let MockService = class MockService {
    constructor(repository, proxyController, flagService) {
        this.repository = repository;
        this.proxyController = proxyController;
        this.flagService = flagService;
    }
    async getRoutes() {
        const options = await this.repository.getMockOptions();
        this.registerHandlebarsHelpers();
        return options.mocks.map(({ id, method, path, response }) => ({
            method, path, handler: this.buildHandler(response, options.data, id)
        }));
    }
    buildHandler(response, data = {}, id) {
        const bodyTemplate = Handlebars.compile(response.body);
        return async (request, h) => {
            const { params, headers, query, payload: body } = request;
            const { code: status } = response;
            const context = {
                request: { params, headers, query, body },
                response: { status, headers: {}, mustProxy: false },
                data
            };
            if (response.delay) {
                await utils_1.sleep(response.delay);
            }
            let resBody;
            try {
                resBody = bodyTemplate(context);
            }
            catch (e) {
                if (id) {
                    await this.registerFailure(id, e);
                }
                throw e;
            }
            if (context.response.mustProxy) {
                return await this.proxyController.proxyRequest(request, h);
            }
            const res = h
                .response(resBody)
                .code(context.response.status);
            Object.entries({ ...response.headers, ...context.response.headers }).forEach(([key, value]) => res.header(key, value));
            return res;
        };
    }
    registerHandlebarsHelpers() {
        helpers([
            'array', 'collection', 'comparison', 'date', 'html', 'i18n',
            'inflection', 'logging', 'markdown', 'match', 'math', 'misc',
            'number', 'object', 'path', 'regex', 'string', 'url'
        ], {
            handlebars: Handlebars,
        });
        Handlebars.registerHelper('setStatus', function (status) {
            this.response.status = status;
        });
        Handlebars.registerHelper('proxy', function () {
            this.response.mustProxy = true;
        });
        Handlebars.registerHelper('setHeader', function (key, value) {
            this.response.headers[key] = value;
        });
        Handlebars.registerHelper('getFlag', (flag) => {
            if (typeof flag !== "string") {
                throw new TypeError("Flag must be a string");
            }
            return this.flagService.getFlag(flag);
        });
        Handlebars.registerHelper('setFlag', (flag, value) => {
            if (typeof flag !== "string") {
                throw new TypeError("Flag must be a string");
            }
            this.flagService.setFlag(flag, value);
        });
        Handlebars.registerHelper('delFlag', (flag) => {
            if (typeof flag !== "string") {
                throw new TypeError("Flag must be a string");
            }
            this.flagService.delFlag(flag);
        });
        const self = this;
        Handlebars.registerHelper('hasFlag', function (flag, options) {
            if (typeof flag !== "string") {
                throw new TypeError("Flag must be a string");
            }
            const hasFlag = self.flagService.hasFlag(flag);
            if (hasFlag) {
                return options.fn(this);
            }
            else if (typeof options.inverse === 'function') {
                return options.inverse(this);
            }
        });
    }
    async registerFailure(id, error) {
        const failure = new mock_failure_1.MockFailure(error.toString(), new Date());
        await this.repository.saveFailure(id, failure);
    }
};
MockService = __decorate([
    service_1.Service(),
    __metadata("design:paramtypes", [mock_repository_1.MockRepository,
        proxy_controller_1.ProxyController,
        flag_service_1.FlagService])
], MockService);
exports.MockService = MockService;
//# sourceMappingURL=mock.service.js.map