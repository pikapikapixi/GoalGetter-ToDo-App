"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRepository = void 0;
const provider_1 = require("../../utils/decorators/provider");
const fs = require("fs");
const mock_options_1 = require("./data/mock-options");
const util_1 = require("util");
const redis_provider_1 = require("../../redis/redis.provider");
const mock_constants_1 = require("./mock.constants");
const hcl_parser_1 = require("hcl-parser");
const utils_1 = require("../../utils/utils");
const inversify_1 = require("inversify");
const logger_1 = require("../../utils/logger");
const readFile = util_1.promisify(fs.readFile);
const readDir = util_1.promisify(fs.readdir);
const lstat = util_1.promisify(fs.lstat);
const MOCKS_DIR = process.env['MOCKS_FOLDER'] || "mocks";
const MUST_LOAD_DIR = !!process.env['MOCKS_FOLDER'];
const HCL_EXTENSION = ".hcl";
const MOCK_FAILURE_DURATION = 10 * 60 * 1000;
let MockRepository = class MockRepository {
    constructor(logger, redis) {
        this.logger = logger;
        this.redis = redis;
    }
    async saveFailure(id, failure) {
        if (!this.redis.isEnabled) {
            return;
        }
        await this.redis.set(`mock_failure:${id}`, failure, MOCK_FAILURE_DURATION);
    }
    async getFileMockOptions() {
        const dirMocks = await this.getMockFilesContent();
        const data = hcl_parser_1.parse(dirMocks);
        return mock_options_1.optionsFromConfig(data[0]);
    }
    async getRedisMockOptions() {
        const mocks = await this.redis.get(mock_constants_1.REDIS_OPTIONS_DEPLOYMENT);
        if (!mocks) {
            return { mocks: [] };
        }
        return mocks;
    }
    async getMockOptions() {
        if (this.redis.isEnabled) {
            return await this.getRedisMockOptions();
        }
        return await this.getFileMockOptions();
    }
    async getMockFilesContent(path = MOCKS_DIR) {
        const fileNames = await readDir(path)
            .catch(utils_1.ignoreErrors());
        if (!fileNames) {
            if (MUST_LOAD_DIR) {
                this.logger.error(`Failed to load the mocks from '${MOCKS_DIR}', make sure it's a directory and your user has read permission on its files`);
                process.exit(1);
            }
            return "";
        }
        const files = await Promise.all(fileNames.map(async (name) => {
            const stat = await lstat(`${path}/${name}`);
            const isDir = stat.isDirectory();
            return { name, isDir };
        }));
        const mocks = files
            .filter(f => !f.isDir)
            .filter(f => f.name.endsWith(HCL_EXTENSION));
        const subDirContents = await Promise.all(files
            .filter(f => f.isDir)
            .map(f => this.getMockFilesContent(`${path}/${f.name}`)));
        const dirContents = await Promise.all(mocks
            .map(m => readFile(`${path}/${m.name}`)));
        return dirContents.map(c => c.toString()).join("\n") + "\n" + subDirContents;
    }
};
MockRepository = __decorate([
    provider_1.Provider(),
    __param(0, inversify_1.inject(logger_1.Logger)),
    __metadata("design:paramtypes", [Object, redis_provider_1.RedisProvider])
], MockRepository);
exports.MockRepository = MockRepository;
//# sourceMappingURL=mock.repository.js.map